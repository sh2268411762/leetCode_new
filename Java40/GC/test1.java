package Java40.GC;

/**
 * @author 枳洛淮南
 * @version 1.0
 * @Description 功能
 * @Date 2021/7/23 9:01
 */
public class test1
{
    public static void main(String[] args)
    {
        O o0 = new O();
        O o5 = new O();
        O o6 = new O();

        o0.o = o5;
        o5.o = o6;

        //GC Roots 断开连接，使（o0 指向的对象和 o0） o5 和 o6 不可达，被判定为可回收对象
        o0 = null;

        //o0 可达，但 o5 和 o6 不可达
        o0.o = null;
        d();

        //强、软、弱、虚
        //强引用：只要强引用还存在，垃圾收集器永远不会回收被引用的对象

        //软引用：用来描述一些还有用但非必需的对象，在系统发生内存溢出一场之前，
        // 会把这些对象列进回收范围之中进行第二次回收
        //softReference；软引用

        //弱引用：描述非必需对象，强度低于软引用，被软引用关联的对象只能生存到下一次垃圾收集发生之前，
        // 当垃圾收集器工作时，无论当前内存是否足够，都会回收点纸杯弱引用关联的对象

        //虚引用：也称为幽灵引用或幻影引用，最弱的一种阴影关系，
        // 一个对象是否有虚引用的存在，
        // 完全不会对其生存时间构成影响，
        // 也无法通过虚引用来取得一个对象实例，
        // 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器会收拾收到一个系统通知

        //标记清除算法（老年代基础收集算法）不足：
        //效率问题：标记和清除两个过程的效率都不高
        //空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多会导致以后在程序运行过程中
        //需要分配较大对象时，无法找到足够的连续内存二不得不提前触发另一次垃圾收集动作

        //标记整理算法（老年代）:
        //清除时让所有存活的对象想一段移动，然后清理掉端便捷以外的内存

        //复制算法（新生代）：
        //将可用内存按容量划分为大小相等的两块，
        // 每次只使用其中的一块。当这一块的内存用完了，
        // 就将还存活着的对象复制到另外—块上面，然
        // 后再把已使用过的内存空间─次清理
        // 掉。
        // 这样使得每次都是对整个半区进行内存回收，
        // 内存分配时也就不用考虑内存碎片等复杂情况，
        // 只要移动堆顶指针，按桢序分配内存即可，
        // 实现简单，运行高效。
        // 不足：只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。内存利用率50%

        //分代收集算法
    }

    public static class O
    {
        private O o;
    }

    public static void d()
    {
        Object[] obj = new Object[20];
        for (int i = 0; i < 20; i++)
        {
            obj[i] = new Object();
        }
    }

    public static void main1(String[] args)
    {
        //建议JVM进行FGC（Full GC） --> 垃圾回收
        System.gc();

        //生命周期的临终方法

    }
}
